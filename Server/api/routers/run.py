# api/routers/run.py

from fastapi import APIRouter, HTTPException
from typing import Dict, Any, List
from services.workflow_orchestrator import workflow_orchestrator # Import the instantiated orchestrator
from pydantic import BaseModel
from datetime import datetime
from db.supabase import get_supabase_client
router = APIRouter()

# Pydantic model for the request payload to execute a workflow
class WorkflowExecuteRequest(BaseModel):
    workflow_id: str
    user_query: str

# Pydantic model for a single chat message in the history
class ChatMessage(BaseModel):
    role: str
    message: str
    timestamp: datetime # Use datetime object for consistency

# Pydantic model for the response, including chat history
class WorkflowExecuteResponse(BaseModel):
    workflow_response: Dict[str, Any]
    chat_history: List[ChatMessage]


@router.post("/execute", response_model=WorkflowExecuteResponse)
async def execute_workflow_endpoint(payload: WorkflowExecuteRequest) -> WorkflowExecuteResponse:
    # ... (previous code for workflow execution) ...

    try:
        # 1. Execute the workflow
        workflow_result = await workflow_orchestrator.execute_workflow(
            workflow_id=payload.workflow_id,
            user_query=payload.user_query
        )
        print(f"[{datetime.now()}] Run Router: Workflow '{payload.workflow_id}' executed successfully.")

        # Extract the final response from the workflow result
        # The 'final_response' key is set by the OutputNode in the orchestrator
        bot_response_message = workflow_result.get("final_response", "No response generated by workflow.")
        
        # 2. Store user query in chat logs (this happens first)
        try:
            await supabase_client.table("chat_logs").insert({
                "workflow_id": payload.workflow_id,
                "role": "user",
                "message": payload.user_query
            }).execute()
            print(f"[{datetime.now()}] Run Router: User message logged.")
        except Exception as log_e:
            print(f"[{datetime.now()}] Run Router: WARNING - Failed to log user message: {log_e}")

        # 3. Store bot response in chat logs (this happens second)
        try:
            await supabase_client.table("chat_logs").insert({
                "workflow_id": payload.workflow_id,
                "role": "bot", # <-- This identifies it as a bot message
                "message": bot_response_message # <-- This is the actual bot's answer
            }).execute()
            print(f"[{datetime.now()}] Run Router: Bot message logged.")
        except Exception as log_e:
            print(f"[{datetime.now()}] Run Router: WARNING - Failed to log bot message: {log_e}")
        # Do not raise HTTPException here, logging failure should not block main functionality

        # 4. Retrieve total chat history for this workflow and user
        chat_history_list: List[ChatMessage] = []
        try:
            chat_history_response = await supabase_client.table("chat_logs") \
                                                        .select("role, message, timestamp") \
                                                        .eq("workflow_id", payload.workflow_id) \
                                                        .order("timestamp", desc=False) \
                                                        .execute()
            
            # Convert fetched data into ChatMessage Pydantic models
            chat_history_list = [ChatMessage(**msg) for msg in chat_history_response.data]
            print(f"[{datetime.now()}] Run Router: Retrieved {len(chat_history_list)} chat messages for workflow '{payload.workflow_id}'.")
        except Exception as fetch_e:
            print(f"[{datetime.now()}] Run Router: WARNING - Failed to fetch chat history: {fetch_e}")
            chat_history_list = [] # Return empty list on error

        # 5. Return the workflow result along with the chat history
        return WorkflowExecuteResponse(
            workflow_response=workflow_result,
            chat_history=chat_history_list
        )

    except HTTPException as http_exc:
        print(f"[{datetime.now()}] Run Router: HTTPException during workflow execution: {http_exc.detail}")
        raise http_exc
    except Exception as e:
        print(f"[{datetime.now()}] Run Router: CRITICAL ERROR during workflow execution for '{payload.workflow_id}': {e}")
        raise HTTPException(status_code=500, detail=f"Failed to execute workflow: {str(e)}")

